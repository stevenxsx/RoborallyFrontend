{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Shroom\\\\IdeaProjects\\\\RoborallyFrontend\\\\roborally_frontend\\\\src\\\\context\\\\GameContextProvider.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useCallback, useEffect, useMemo, useState } from \"react\";\nimport GameContext from \"./GameContext\";\nimport GameApi from \"../api/GameApi\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst GameContextProvider = ({\n  children\n}) => {\n  _s();\n\n  const [loaded, setLoaded] = useState(false);\n  useEffect(() => {\n    GameApi.getBoard(1).then(board => {\n      setSpaces(board.spaceDtos);\n      setPlayers(board.playerDtos);\n      setWidth(board.width);\n      setHeight(board.height);\n      setGameId(board.boardId);\n      setGameName(board.boardName);\n\n      if (board.currentPlayerDto) {\n        setCurrentPlayer(board.currentPlayerDto);\n        board.playerDtos.forEach((player, index) => {\n          var _board$currentPlayerD;\n\n          if (player.playerId === ((_board$currentPlayerD = board.currentPlayerDto) === null || _board$currentPlayerD === void 0 ? void 0 : _board$currentPlayerD.playerId)) {\n            setCurrentPlayerIndex(index);\n          }\n        });\n      }\n\n      setLoaded(true);\n    }).catch(() => {\n      console.error(\"Error while fetching board from backend\");\n    });\n  }, []); //The code below is executed when the provider is rendered (inside App.tsx)\n  //The code should fetch the data from the API instead of using a static assignment\n  //Define a useState variable, note that useState returns an array, containing that state itself aswell as\n  // a function to set a new state value, here we use array destructuring (the [..., ...] notation).\n  // we also declare that the state variable and setter should be of type /take type Player[]\n\n  const [players, setPlayers] = useState([]);\n  const playerCount = useMemo(() => players.length, [players]);\n  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);\n  const [currentPlayer, setCurrentPlayer] = useState({\n    playerId: -1,\n    playerColor: \"red\",\n    boardId: -1,\n    playerName: \"\"\n  });\n  const [spaces, setSpaces] = useState([]);\n  const [width, setWidth] = useState(0);\n  const [height, setHeight] = useState(0);\n  const [gameId, setGameId] = useState(0);\n  const [gameName, setGameName] = useState(\"hi\"); //Define a function used to set a player ona  specific space\n\n  const setPlayerOnSpace = useCallback(async space => {\n    //Check if space already has a player standing on it\n    if (!space.playerId) {\n      await GameApi.moveCurrentPlayer(gameId, { ...space,\n        playerId: currentPlayer.playerId\n      }).then(() => {\n        let tempSpaces = [...spaces]; //Use spread operator to copy spaces array, needed for making immutable changes\n        //See https://bit.ly/2My8Bfz, until the section about Immutable.js\n\n        tempSpaces[space.x][space.y].playerId = currentPlayer.playerId; //Set the player on the new space they clicked on\n\n        if (currentPlayer.x !== undefined && currentPlayer.y !== undefined) {\n          //If the player was standing on a space previously, remove them from that space\n          tempSpaces[currentPlayer.x][currentPlayer.y].playerId = undefined;\n        }\n\n        setSpaces(tempSpaces);\n        let tempPlayers = [...players];\n        tempPlayers[currentPlayerIndex].x = space.x; //Update the players array to reflect the changes\n\n        tempPlayers[currentPlayerIndex].y = space.y; //Update the players array to reflect the changes\n\n        setPlayers(tempPlayers);\n        setCurrentPlayer({ ...currentPlayer,\n          x: space.x,\n          y: space.y\n        }); //Update current player\n      }).catch(() => {\n        console.error(\"Error while moving player\");\n      });\n    }\n  }, [currentPlayer, currentPlayerIndex, gameId, players, spaces]);\n  const switchToNextPlayer = useCallback(async () => {\n    await GameApi.switchPlayer(gameId).then(() => {\n      const newPlayerIndex = (currentPlayerIndex + 1) % playerCount;\n      console.log(\"old player index\", currentPlayerIndex, \"new player index\", newPlayerIndex);\n      setCurrentPlayer(players[newPlayerIndex]);\n      setCurrentPlayerIndex(newPlayerIndex);\n    }).catch(() => console.error(\"Error while switching player\"));\n  }, [currentPlayerIndex, gameId, playerCount, players]);\n  const board = useMemo(() => {\n    return {\n      spaceDtos: spaces,\n      playerDtos: players,\n      currentPlayerDto: currentPlayer,\n      currentPlayerIndex: currentPlayerIndex,\n      width: width,\n      height: height,\n      boardName: gameName,\n      boardId: gameId\n    };\n  }, [currentPlayer, currentPlayerIndex, gameId, gameName, height, players, spaces, width]);\n  return /*#__PURE__*/_jsxDEV(GameContext.Provider, {\n    value: {\n      loaded: loaded,\n      board: board,\n      setCurrentPlayerOnSpace: setPlayerOnSpace,\n      switchCurrentPlayer: switchToNextPlayer\n    },\n    children: [children, \" \"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 104,\n    columnNumber: 9\n  }, this);\n};\n\n_s(GameContextProvider, \"kQsn/5/PkatGzM1tSSSi/c7C3YE=\");\n\n_c = GameContextProvider;\nexport default GameContextProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"GameContextProvider\");","map":{"version":3,"sources":["C:/Users/Shroom/IdeaProjects/RoborallyFrontend/roborally_frontend/src/context/GameContextProvider.tsx"],"names":["React","useCallback","useEffect","useMemo","useState","GameContext","GameApi","GameContextProvider","children","loaded","setLoaded","getBoard","then","board","setSpaces","spaceDtos","setPlayers","playerDtos","setWidth","width","setHeight","height","setGameId","boardId","setGameName","boardName","currentPlayerDto","setCurrentPlayer","forEach","player","index","playerId","setCurrentPlayerIndex","catch","console","error","players","playerCount","length","currentPlayerIndex","currentPlayer","playerColor","playerName","spaces","gameId","gameName","setPlayerOnSpace","space","moveCurrentPlayer","tempSpaces","x","y","undefined","tempPlayers","switchToNextPlayer","switchPlayer","newPlayerIndex","log","setCurrentPlayerOnSpace","switchCurrentPlayer"],"mappings":"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","sourcesContent":["import React, {ReactNode, useCallback, useEffect, useMemo, useState} from \"react\"\nimport GameContext from \"./GameContext\"\nimport {Player} from \"../types/Player\";\nimport {Board} from \"../types/Board\";\nimport {Space} from \"../types/Space\";\nimport GameApi from \"../api/GameApi\";\n\ntype GameContextProviderPropsType = {\n    children: ReactNode\n}\n\n\nconst GameContextProvider = ({children}: GameContextProviderPropsType) => {\n    const [loaded, setLoaded] = useState<boolean>(false)\n    useEffect(() => {\n        GameApi.getBoard(1).then(board => {\n            setSpaces(board.spaceDtos)\n            setPlayers(board.playerDtos)\n            setWidth(board.width)\n            setHeight(board.height)\n            setGameId(board.boardId)\n            setGameName(board.boardName)\n            if (board.currentPlayerDto) {\n                setCurrentPlayer(board.currentPlayerDto)\n                board.playerDtos.forEach((player,index)=>{\n                    if(player.playerId === board.currentPlayerDto?.playerId){\n                        setCurrentPlayerIndex(index)\n                    }\n                })\n\n            }\n\n            setLoaded(true)\n        }).catch(() => {\n            console.error(\"Error while fetching board from backend\")\n        })\n    }, [])\n    //The code below is executed when the provider is rendered (inside App.tsx)\n    //The code should fetch the data from the API instead of using a static assignment\n    //Define a useState variable, note that useState returns an array, containing that state itself aswell as\n    // a function to set a new state value, here we use array destructuring (the [..., ...] notation).\n    // we also declare that the state variable and setter should be of type /take type Player[]\n    const [players, setPlayers] = useState<Player[]>([])\n    const playerCount = useMemo(() => players.length, [players])\n    const [currentPlayerIndex, setCurrentPlayerIndex] = useState<number>(0)\n    const [currentPlayer, setCurrentPlayer] = useState<Player>({playerId : -1,playerColor:\"red\",boardId : -1,playerName : \"\"})\n    const [spaces, setSpaces] = useState<Space[][]>([])\n    const [width, setWidth] = useState<number>(0)\n    const [height, setHeight] = useState<number>(0)\n    const [gameId, setGameId] = useState<number>(0)\n    const [gameName, setGameName] = useState<string>(\"hi\")\n\n    //Define a function used to set a player ona  specific space\n    const setPlayerOnSpace = useCallback(async (space: Space) => {\n        //Check if space already has a player standing on it\n        if (!space.playerId) {\n            await GameApi.moveCurrentPlayer(gameId, {...space, playerId: currentPlayer.playerId}).then(() => {\n                let tempSpaces = [...spaces] //Use spread operator to copy spaces array, needed for making immutable changes\n                //See https://bit.ly/2My8Bfz, until the section about Immutable.js\n                tempSpaces[space.x][space.y].playerId = currentPlayer.playerId //Set the player on the new space they clicked on\n\n                if (currentPlayer.x !== undefined && currentPlayer.y !== undefined) { //If the player was standing on a space previously, remove them from that space\n                    tempSpaces[currentPlayer.x][currentPlayer.y].playerId = undefined\n                }\n                setSpaces(tempSpaces)\n                let tempPlayers = [...players]\n                tempPlayers[currentPlayerIndex].x = space.x; //Update the players array to reflect the changes\n                tempPlayers[currentPlayerIndex].y = space.y; //Update the players array to reflect the changes\n                setPlayers(tempPlayers)\n                setCurrentPlayer({...currentPlayer, x: space.x, y: space.y}) //Update current player\n\n            }).catch(() => {\n                console.error(\"Error while moving player\")\n            })\n\n        }\n\n    }, [currentPlayer, currentPlayerIndex, gameId, players, spaces])\n\n    const switchToNextPlayer = useCallback(async () => {\n        await GameApi.switchPlayer(gameId).then(()=>{\n            const newPlayerIndex = (currentPlayerIndex + 1) % playerCount\n            console.log(\"old player index\", currentPlayerIndex, \"new player index\", newPlayerIndex)\n            setCurrentPlayer(players[newPlayerIndex])\n            setCurrentPlayerIndex(newPlayerIndex)\n        }).catch(()=>console.error(\"Error while switching player\"))\n        \n    }, [currentPlayerIndex, gameId, playerCount, players])\n    const board = useMemo<Board>(() => {\n        return ({\n            spaceDtos: spaces,\n            playerDtos: players,\n            currentPlayerDto: currentPlayer,\n            currentPlayerIndex: currentPlayerIndex,\n            width: width,\n            height: height,\n            boardName: gameName,\n            boardId: gameId\n        })\n    }, [currentPlayer, currentPlayerIndex, gameId, gameName, height, players, spaces, width])\n\n\n    return (\n        <GameContext.Provider\n            value={\n                {\n                    loaded: loaded,\n                    board: board,\n                    setCurrentPlayerOnSpace: setPlayerOnSpace,\n                    switchCurrentPlayer: switchToNextPlayer\n                }\n            }>\n            {children} {/*See: https://reactjs.org/docs/composition-vs-inheritance.html*/}\n        </GameContext.Provider>\n    )\n}\n\nexport default GameContextProvider"]},"metadata":{},"sourceType":"module"}